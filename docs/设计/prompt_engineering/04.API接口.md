# PromptEngineering API接口

## 1. Architecture（架构设计）

### 1.1 API架构概述
PromptEngineering 模块采用 Wails v2 框架的前后端绑定机制，通过Go方法直接暴露给前端调用，同时结合事件系统实现流式数据传输和实时通信。

### 1.2 通信架构
```
前端 Vue 组件
    ↕ (方法调用)
Wails 绑定层
    ↕ (Go方法)
业务服务层
    ↕ (事件广播)
前端事件监听
```

### 1.3 API设计原则
- **RESTful风格**: 遵循REST设计规范
- **类型安全**: TypeScript/Go强类型定义
- **错误统一**: 统一的错误处理机制
- **异步优先**: 支持流式和异步操作

## 2. Analysis（需求分析）

### 2.1 API功能分析
| 功能模块 | API数量 | 复杂度 | 优先级 |
|---------|---------|--------|--------|
| 提示词生成 | 2 | 高 | P0 |
| 提示词管理 | 5 | 中 | P0 |
| 模型管理 | 3 | 低 | P1 |
| 服务器管理 | 4 | 中 | P1 |
| 标签管理 | 3 | 低 | P2 |

### 2.2 调用频率分析
- **高频调用**: 提示词生成、模型列表获取
- **中频调用**: 提示词CRUD、服务器状态检查
- **低频调用**: 配置管理、数据导入导出

### 2.3 性能要求
- **响应时间**: 普通API <200ms，流式API <50ms首字节
- **并发支持**: 支持3个模型同时生成
- **错误恢复**: 自动重试和降级机制

## 3. Architecture（API架构）

### 3.1 核心API接口

#### 3.1.1 提示词生成API
```go
// 提示词生成服务
type PromptGenerationAPI struct {
    service *PromptService
    ctx     context.Context
}

// 流式生成提示词
func (api *PromptGenerationAPI) GeneratePromptStream(req GenerateRequest) error {
    // 参数验证
    if err := api.validateGenerateRequest(req); err != nil {
        return err
    }
    
    // 并行生成
    for _, model := range req.Models {
        go api.generateForModel(req, model)
    }
    
    return nil
}

// 单模型重新生成
func (api *PromptGenerationAPI) RegenerateForModel(req RegenerateRequest) error {
    return api.generateForModel(GenerateRequest{
        Idea:     req.Idea,
        ServerID: req.ServerID,
        Models:   []string{req.Model},
        Options:  req.Options,
    }, req.Model)
}
```

#### 3.1.2 提示词管理API
```go
// 提示词管理服务
type PromptManagementAPI struct {
    repository PromptRepository
    validator  PromptValidator
}

// 创建提示词
func (api *PromptManagementAPI) CreatePrompt(prompt Prompt) (*Prompt, error) {
    // 数据验证
    if err := api.validator.Validate(&prompt); err != nil {
        return nil, err
    }
    
    // 生成ID和时间戳
    prompt.ID = generateID()
    prompt.CreatedAt = time.Now()
    prompt.UpdatedAt = time.Now()
    
    // 保存到数据库
    if err := api.repository.Create(&prompt); err != nil {
        return nil, err
    }
    
    return &prompt, nil
}

// 获取提示词列表
func (api *PromptManagementAPI) ListPrompts(filter PromptFilter) (*PromptListResponse, error) {
    prompts, total, err := api.repository.ListWithTotal(filter)
    if err != nil {
        return nil, err
    }
    
    return &PromptListResponse{
        Prompts: prompts,
        Total:   total,
        Page:    filter.Page,
        Size:    filter.PageSize,
    }, nil
}

// 更新提示词
func (api *PromptManagementAPI) UpdatePrompt(prompt Prompt) (*Prompt, error) {
    // 检查是否存在
    existing, err := api.repository.GetByID(prompt.ID)
    if err != nil {
        return nil, err
    }
    if existing == nil {
        return nil, errors.New("提示词不存在")
    }
    
    // 数据验证
    if err := api.validator.Validate(&prompt); err != nil {
        return nil, err
    }
    
    // 更新时间戳和版本
    prompt.UpdatedAt = time.Now()
    prompt.Version = existing.Version + 1
    
    if err := api.repository.Update(&prompt); err != nil {
        return nil, err
    }
    
    return &prompt, nil
}

// 删除提示词
func (api *PromptManagementAPI) DeletePrompt(id string) error {
    return api.repository.Delete(id)
}

// 搜索提示词
func (api *PromptManagementAPI) SearchPrompts(query SearchRequest) (*PromptListResponse, error) {
    prompts, total, err := api.repository.Search(query)
    if err != nil {
        return nil, err
    }
    
    return &PromptListResponse{
        Prompts: prompts,
        Total:   total,
        Page:    query.Page,
        Size:    query.PageSize,
    }, nil
}
```

#### 3.1.3 模型管理API
```go
// 模型管理服务
type ModelManagementAPI struct {
    ollamaClient *OllamaClient
    cache        *ModelCache
}

// 获取可用模型列表
func (api *ModelManagementAPI) GetAvailableModels(serverID string) ([]Model, error) {
    // 检查缓存
    if models := api.cache.Get(serverID); models != nil {
        return models, nil
    }
    
    // 从Ollama服务获取
    models, err := api.ollamaClient.ListModels(serverID)
    if err != nil {
        return nil, err
    }
    
    // 更新缓存
    api.cache.Set(serverID, models, 5*time.Minute)
    
    return models, nil
}

// 检查模型状态
func (api *ModelManagementAPI) CheckModelStatus(serverID, modelName string) (*ModelStatus, error) {
    return api.ollamaClient.GetModelInfo(serverID, modelName)
}

// 刷新模型缓存
func (api *ModelManagementAPI) RefreshModelCache(serverID string) error {
    api.cache.Delete(serverID)
    _, err := api.GetAvailableModels(serverID)
    return err
}
```

### 3.2 事件系统API

#### 3.2.1 事件定义
```go
// 事件类型常量
const (
    EventPromptStream      = "prompt_pilot_stream"
    EventPromptStreamError = "prompt_pilot_stream_error"
    EventPromptStreamDone  = "prompt_pilot_stream_done"
    EventModelStatusChange = "model_status_change"
    EventServerStatusChange = "server_status_change"
)

// 流式事件数据
type StreamEventData struct {
    Model     string `json:"model"`
    Chunk     string `json:"chunk"`
    Timestamp int64  `json:"timestamp"`
}

// 错误事件数据
type ErrorEventData struct {
    Model     string `json:"model"`
    Error     string `json:"error"`
    Code      string `json:"code"`
    Timestamp int64  `json:"timestamp"`
}

// 完成事件数据
type DoneEventData struct {
    Model     string `json:"model"`
    Total     int    `json:"total"`
    Timestamp int64  `json:"timestamp"`
}
```

#### 3.2.2 事件发送器
```go
// 事件发送服务
type EventEmitter struct {
    ctx *wails.Context
}

// 发送流式数据
func (e *EventEmitter) EmitStreamData(model, chunk string) {
    e.ctx.Events.Emit(EventPromptStream, StreamEventData{
        Model:     model,
        Chunk:     chunk,
        Timestamp: time.Now().UnixMilli(),
    })
}

// 发送错误事件
func (e *EventEmitter) EmitError(model, error, code string) {
    e.ctx.Events.Emit(EventPromptStreamError, ErrorEventData{
        Model:     model,
        Error:     error,
        Code:      code,
        Timestamp: time.Now().UnixMilli(),
    })
}

// 发送完成事件
func (e *EventEmitter) EmitDone(model string, total int) {
    e.ctx.Events.Emit(EventPromptStreamDone, DoneEventData{
        Model:     model,
        Total:     total,
        Timestamp: time.Now().UnixMilli(),
    })
}
```

### 3.3 数据传输对象

#### 3.3.1 请求对象
```go
// 生成请求
type GenerateRequest struct {
    Idea     string            `json:"idea" validate:"required,min=1,max=2000"`
    ServerID string            `json:"serverId" validate:"required"`
    Models   []string          `json:"models" validate:"required,min=1,max=3"`
    Options  *GenerateOptions  `json:"options,omitempty"`
}

// 生成选项
type GenerateOptions struct {
    Temperature *float64 `json:"temperature,omitempty" validate:"omitempty,min=0,max=2"`
    MaxTokens   *int     `json:"maxTokens,omitempty" validate:"omitempty,min=1,max=4000"`
    Stream      *bool    `json:"stream,omitempty"`
}

// 重新生成请求
type RegenerateRequest struct {
    Idea     string           `json:"idea" validate:"required"`
    ServerID string           `json:"serverId" validate:"required"`
    Model    string           `json:"model" validate:"required"`
    Options  *GenerateOptions `json:"options,omitempty"`
}

// 提示词过滤器
type PromptFilter struct {
    ServerID   string   `json:"serverId,omitempty"`
    Tags       []string `json:"tags,omitempty"`
    Models     []string `json:"models,omitempty"`
    SearchText string   `json:"searchText,omitempty"`
    SortBy     string   `json:"sortBy,omitempty" validate:"omitempty,oneof=name createdAt updatedAt usage rating"`
    SortOrder  string   `json:"sortOrder,omitempty" validate:"omitempty,oneof=asc desc"`
    Page       int      `json:"page" validate:"min=1"`
    PageSize   int      `json:"pageSize" validate:"min=1,max=100"`
}

// 搜索请求
type SearchRequest struct {
    Query    string `json:"query" validate:"required,min=1"`
    Page     int    `json:"page" validate:"min=1"`
    PageSize int    `json:"pageSize" validate:"min=1,max=100"`
}
```

#### 3.3.2 响应对象
```go
// 提示词列表响应
type PromptListResponse struct {
    Prompts []Prompt `json:"prompts"`
    Total   int      `json:"total"`
    Page    int      `json:"page"`
    Size    int      `json:"size"`
}

// 模型状态响应
type ModelStatus struct {
    Name      string    `json:"name"`
    Available bool      `json:"available"`
    Size      string    `json:"size"`
    LoadedAt  time.Time `json:"loadedAt"`
}

// 服务器状态响应
type ServerStatus struct {
    ID        string    `json:"id"`
    Status    string    `json:"status"`
    Version   string    `json:"version"`
    Models    int       `json:"models"`
    CheckedAt time.Time `json:"checkedAt"`
}

// 统一API响应包装
type ApiResponse struct {
    Success   bool        `json:"success"`
    Data      interface{} `json:"data,omitempty"`
    Error     string      `json:"error,omitempty"`
    Code      string      `json:"code,omitempty"`
    Timestamp int64       `json:"timestamp"`
}
```

## 4. Application（应用实现）

### 4.1 前端API调用

#### 4.1.1 TypeScript接口定义
```typescript
// Wails绑定接口
declare global {
  interface Window {
    go: {
      main: {
        PromptEngineering: {
          // 提示词生成
          GeneratePromptStream(req: GenerateRequest): Promise<void>;
          RegenerateForModel(req: RegenerateRequest): Promise<void>;
          
          // 提示词管理
          CreatePrompt(prompt: Prompt): Promise<Prompt>;
          ListPrompts(filter: PromptFilter): Promise<PromptListResponse>;
          UpdatePrompt(prompt: Prompt): Promise<Prompt>;
          DeletePrompt(id: string): Promise<void>;
          SearchPrompts(query: SearchRequest): Promise<PromptListResponse>;
          
          // 模型管理
          GetAvailableModels(serverId: string): Promise<Model[]>;
          CheckModelStatus(serverId: string, modelName: string): Promise<ModelStatus>;
          RefreshModelCache(serverId: string): Promise<void>;
          
          // 服务器管理
          ListServers(): Promise<Server[]>;
          CheckServerStatus(serverId: string): Promise<ServerStatus>;
        };
      };
    };
  }
}
```

#### 4.1.2 API调用封装
```typescript
// API调用服务
class PromptEngineeringAPI {
  // 生成提示词
  async generatePrompts(req: GenerateRequest): Promise<void> {
    try {
      await window.go.main.PromptEngineering.GeneratePromptStream(req);
    } catch (error) {
      throw new APIError('生成失败', error);
    }
  }
  
  // 获取提示词列表
  async getPrompts(filter: PromptFilter): Promise<PromptListResponse> {
    try {
      return await window.go.main.PromptEngineering.ListPrompts(filter);
    } catch (error) {
      throw new APIError('获取提示词列表失败', error);
    }
  }
  
  // 保存提示词
  async savePrompt(prompt: Prompt): Promise<Prompt> {
    try {
      if (prompt.id) {
        return await window.go.main.PromptEngineering.UpdatePrompt(prompt);
      } else {
        return await window.go.main.PromptEngineering.CreatePrompt(prompt);
      }
    } catch (error) {
      throw new APIError('保存提示词失败', error);
    }
  }
}

// 错误处理类
class APIError extends Error {
  constructor(message: string, cause?: any) {
    super(message);
    this.name = 'APIError';
    this.cause = cause;
  }
}
```

### 4.2 错误处理机制

#### 4.2.1 错误码定义
```go
// 错误码常量
const (
    ErrCodeValidation    = "VALIDATION_ERROR"
    ErrCodeNotFound      = "NOT_FOUND"
    ErrCodeDuplicate     = "DUPLICATE_ERROR"
    ErrCodeNetwork       = "NETWORK_ERROR"
    ErrCodeTimeout       = "TIMEOUT_ERROR"
    ErrCodeServerError   = "SERVER_ERROR"
    ErrCodeUnauthorized  = "UNAUTHORIZED"
    ErrCodeRateLimit     = "RATE_LIMIT"
)

// 自定义错误类型
type APIError struct {
    Code    string `json:"code"`
    Message string `json:"message"`
    Details string `json:"details,omitempty"`
}

func (e *APIError) Error() string {
    return e.Message
}
```

#### 4.2.2 错误处理中间件
```go
// 错误处理装饰器
func WithErrorHandling(fn func() error) error {
    defer func() {
        if r := recover(); r != nil {
            log.Printf("API panic recovered: %v", r)
        }
    }()
    
    if err := fn(); err != nil {
        return handleError(err)
    }
    
    return nil
}

// 统一错误处理
func handleError(err error) error {
    switch {
    case errors.Is(err, gorm.ErrRecordNotFound):
        return &APIError{
            Code:    ErrCodeNotFound,
            Message: "记录不存在",
        }
    case strings.Contains(err.Error(), "validation"):
        return &APIError{
            Code:    ErrCodeValidation,
            Message: "数据验证失败",
            Details: err.Error(),
        }
    case strings.Contains(err.Error(), "timeout"):
        return &APIError{
            Code:    ErrCodeTimeout,
            Message: "请求超时",
        }
    default:
        return &APIError{
            Code:    ErrCodeServerError,
            Message: "服务器内部错误",
            Details: err.Error(),
        }
    }
}
```

### 4.3 性能优化

#### 4.3.1 缓存策略
```go
// 缓存管理器
type CacheManager struct {
    cache map[string]*CacheItem
    mutex sync.RWMutex
    ttl   time.Duration
}

type CacheItem struct {
    Data      interface{}
    ExpiresAt time.Time
}

// 获取缓存
func (c *CacheManager) Get(key string) interface{} {
    c.mutex.RLock()
    defer c.mutex.RUnlock()
    
    item, exists := c.cache[key]
    if !exists || time.Now().After(item.ExpiresAt) {
        return nil
    }
    
    return item.Data
}

// 设置缓存
func (c *CacheManager) Set(key string, data interface{}, ttl time.Duration) {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    
    c.cache[key] = &CacheItem{
        Data:      data,
        ExpiresAt: time.Now().Add(ttl),
    }
}
```

#### 4.3.2 请求限流
```go
// 限流器
type RateLimiter struct {
    requests map[string][]time.Time
    mutex    sync.RWMutex
    limit    int
    window   time.Duration
}

// 检查是否允许请求
func (r *RateLimiter) Allow(key string) bool {
    r.mutex.Lock()
    defer r.mutex.Unlock()
    
    now := time.Now()
    requests := r.requests[key]
    
    // 清理过期请求
    var validRequests []time.Time
    for _, req := range requests {
        if now.Sub(req) < r.window {
            validRequests = append(validRequests, req)
        }
    }
    
    // 检查是否超限
    if len(validRequests) >= r.limit {
        return false
    }
    
    // 记录新请求
    validRequests = append(validRequests, now)
    r.requests[key] = validRequests
    
    return true
}
```

## 5. Assurance（质量保证）

### 5.1 API测试策略
- **单元测试**: 每个API方法的独立测试
- **集成测试**: 前后端完整流程测试
- **性能测试**: 并发和压力测试
- **错误测试**: 异常情况处理测试

### 5.2 API文档生成
- **自动生成**: 基于代码注释生成文档
- **交互式文档**: 支持在线测试
- **版本管理**: API版本变更记录
- **示例代码**: 完整的调用示例

### 5.3 监控和日志
- **调用统计**: API调用次数和耗时
- **错误监控**: 错误率和错误类型统计
- **性能监控**: 响应时间和资源使用
- **审计日志**: 重要操作的审计记录

## 6. Action（行动计划）

### 6.1 API开发计划

#### 阶段1: 核心API (1周)
- ✅ 提示词生成API
- ✅ 基础CRUD API
- 🔄 事件系统完善
- 🔄 错误处理统一

#### 阶段2: 高级功能 (1周)
- 🔄 搜索和过滤API
- 🔄 批量操作API
- 🔄 缓存机制实现
- 🔄 性能优化

#### 阶段3: 完善和优化 (1周)
- 📅 API文档生成
- 📅 测试用例完善
- 📅 监控和日志
- 📅 安全加固

### 6.2 API版本管理
- **版本策略**: 语义化版本控制
- **兼容性**: 向后兼容保证
- **废弃策略**: 渐进式废弃机制
- **迁移指南**: 版本升级指导