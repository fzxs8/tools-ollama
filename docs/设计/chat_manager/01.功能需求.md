# ChatManager功能需求

## 模块概述

ChatManager 是一个负责处理与大语言模型聊天交互的核心模块。它提供完整的、可持久化的多对话聊天功能，支持多种AI服务提供者（如Ollama等）。

它提供统一的接口来管理不同AI提供者的聊天功能（阻塞与流式），并负责对话的创建、加载、保存、删除和展示。

## 核心功能

### 1. 对话管理 (Conversation Management)

#### 1.1 基本对话操作
- **新建对话**: 用户可以随时创建新的对话，清空当前聊天上下文。
- **历史对话**: 提供一个从右侧滑出的抽屉，展示所有已保存的历史对话列表。
- **加载对话**: 用户可以从历史列表中选择任一对话，系统会将其完整地加载并还原到当前聊天界面，包括所有消息、当时使用的模型和相关参数。
- **自动保存**: 对话会自动进行持久化保存，无需用户手动操作。新的消息会实时更新到当前对话中。

#### 1.2 对话管理操作
- **编辑对话标题**: 用户可以修改历史对话的标题，便于识别和管理。
- **删除对话**: 用户可以删除不需要的历史对话，释放存储空间。
- **标题管理**: 
    - 新对话的标题会根据用户的第一条消息自动生成。
    - 用户可以随时手动修改对话标题。

### 2. 聊天消息管理

#### 2.1 消息交互
- **阻塞式聊天**: 发送聊天消息并等待完整响应。
- **流式聊天**: 通过 **Wails Events** 机制，将AI生成的词语块实时推送到前端，实现流畅的打字机效果。

#### 2.2 消息操作
- **复制消息**: 用户可以复制任意一条消息的内容。
- **重新生成**: 用户可以要求重新生成助手的回复。

### 3. AI提供者适配

- **多提供者支持**: 底层设计支持多种AI服务提供者（如Ollama等）。
- **动态切换**: 支持在不同的服务配置（本地或远程）之间切换，并加载对应服务器上的模型列表。

### 4. 存储管理

- **对话持久化**: 使用 `duolasdk/core/store.go` 提供的哈希存储功能 (`HSet`, `HGetAll`, `HDel`)，将所有对话以JSON格式持久化到SQLite数据库中，确保数据不会丢失。
- **键名**: 所有对话都存储在名为 `"conversations"` 的单个哈希表中。
- **系统提示词存储**: 提供系统提示词的存储管理，支持提示词的增删改查操作。

### 5. 日志和错误处理

- **日志记录**: 在关键路径（如对话保存、加载、API调用）提供详细的调试和错误日志。
- **错误处理**: 统一的错误处理机制，并在前端通过消息提示给用户反馈。
- **异常恢复**: 提供异常情况的恢复机制，确保系统稳定性。

## 数据结构

### 对话结构 (Conversation)

```go
// Conversation 定义了一个完整的对话会话
type Conversation struct {
	ID           string    `json:"id"`
	Title        string    `json:"title"`
	Messages     []Message `json:"messages"`
	ModelName    string    `json:"modelName"`
	SystemPrompt string    `json:"systemPrompt"` // JSON string of the active system prompt
	ModelParams  string    `json:"modelParams"`  // JSON string of the model parameters
	Timestamp    int64     `json:"timestamp"`
}
```

### 消息结构 (Message)

```go
// Message 聊天消息结构
type Message struct {
    Role    string `json:"role"`    // 消息角色 (system/user/assistant)
    Content string `json:"content"` // 消息内容
}
```

## 交互逻辑

### 新建对话流程
1. 用户点击【新建对话】按钮。
2. 前端重置当前会话状态（清空消息列表，清除当前对话ID）。
3. 界面显示初始欢迎语。

### 发送消息流程
1. 用户输入消息并发送。
2. **如果是新对话**: 前端使用用户的第一条消息作为临时标题，构建一个新的 `Conversation` 对象。
3. **如果是历史对话**: 前端将新消息追加到当前已加载的 `Conversation` 对象中。
4. 前端调用后端 `ChatMessage` 方法。
5. 后端通过Wails Events (`chat_stream_chunk`) 实时返回AI响应。
6. 聊天流结束后，前端将包含AI完整回复的 `Conversation` 对象发送给后端 `SaveConversation` 方法进行持久化保存。
7. **如果是新对话**: 保存成功后，前端刷新历史对话列表。

### 加载历史对话流程
1. 用户点击【历史对话】按钮，打开抽屉。
2. 前端调用后端 `ListConversations` 方法，获取所有对话的列表并渲染。
3. 用户点击列表中的某一项。
4. 前端调用后端 `GetConversation(id)` 方法获取完整的对话数据。
5. 前端将获取到的对话数据填充到聊天界面，完成还原。

### 对话自动保存机制
1. 每当用户发送新消息或AI回复完成后，系统会自动触发保存机制。
2. 前端构造包含最新消息的完整对话对象。
3. 调用后端 `SaveConversation` 接口进行保存。
4. 保存成功后更新本地对话列表缓存。

### 对话删除机制
1. 用户在历史对话列表中选择删除某个对话。
2. 前端弹出确认对话框，避免误删。
3. 用户确认后，前端调用后端 `DeleteConversation` 接口。
4. 删除成功后，前端从本地列表中移除该对话并更新界面。