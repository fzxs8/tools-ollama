# Ollama API 调试器模块 - API 接口

## 1. Architecture（架构设计）

### 1.1 API架构概述
Ollama API 调试器采用 Wails v2 框架的前后端绑定机制，通过Go方法直接暴露给前端调用。后端直接使用Go标准库net/http进行HTTP请求，确保对请求的完全控制。

### 1.2 通信架构
```
前端 Vue 组件
    ↕ (Wails 方法调用)
Wails 绑定层
    ↕ (Go 方法)
业务服务层
    ↕ (net/http)
Ollama API 服务
```

### 1.3 API设计原则
- **直接调用**: 绕过中间封装，直接使用net/http
- **类型安全**: TypeScript/Go强类型定义
- **错误统一**: 统一的错误处理机制
- **完全可控**: 前端所见即后端所发

## 2. Analysis（需求分析）

### 2.1 API功能分析
| 功能模块 | API数量 | 复杂度 | 优先级 |
|---------|---------|--------|--------|
| HTTP请求发送 | 1 | 高 | P0 |
| 服务器配置获取 | 1 | 低 | P0 |
| 请求取消 | 1 | 中 | P1 |
| 请求历史 | 3 | 中 | P2 |

### 2.2 调用频率分析
- **高频调用**: SendHttpRequest (每次测试都调用)
- **低频调用**: GetOllamaServers (初始化时调用)
- **中频调用**: 请求取消、历史管理 (用户主动触发)

### 2.3 性能要求
- **响应时间**: 普通API <100ms，HTTP请求取决于目标服务
- **并发支持**: 支持多个并发请求
- **超时处理**: 30秒超时保护

## 3. Architecture（API架构）

### 3.1 核心API接口

#### 3.1.1 SendHttpRequest
*   **功能**: 接收前端构建的 `ApiRequest` 对象，直接使用 Go 标准库 `net/http` 发送一个 HTTP 请求，并返回一个 `ApiResponse` 对象。
*   **方法签名**:
    ```go
    func (a *App) SendHttpRequest(request types.ApiRequest) (types.ApiResponse, error)
    ```
*   **参数**:
    *   `request`: `types.ApiRequest`，包含前端用户构建的所有请求信息。
*   **返回**:
    *   `types.ApiResponse`，包含响应状态码、响应头、响应体、请求耗时和可能的错误信息。
*   **实现细节**:
    1.  **获取 Base URL**: 根据 `request.SelectedServerID` 从 `configMgr` 调用 `GetServerByID` 获取对应的 `OllamaServerConfig`，从而得到 Base URL。
    2.  **构建完整 URL**: 使用 `url.JoinPath` 和 `url.Parse` 将 Base URL、API 路径和用户定义的查询参数拼接成最终的请求 URL。
    3.  **准备请求体**: 根据 `request.Body.Type` (raw, formData, none)，使用 `strings.NewReader` 创建一个 `io.Reader` 作为请求体。同时，根据类型确定 `Content-Type`。
    4.  **创建标准请求**: 调用 `http.NewRequestWithContext` 创建一个 `*http.Request` 对象。
    5.  **设置请求头**: 手动遍历 `request.Headers`，并将所有启用的请求头（包括上一步确定的 `Content-Type`）逐一设置到 `req.Header` 中。这是为了保证对请求头的完全控制。
    6.  **发送请求**: 创建一个标准的 `*http.Client`，并调用其 `Do` 方法发送请求。
    7.  **处理响应**: 读取 `*http.Response` 的状态码、响应头和响应体，计算总耗时，并将所有信息组装成 `types.ApiResponse` 返回。

#### 3.1.2 GetOllamaServers
*   **功能**: 获取所有已配置的 Ollama 服务列表。
*   **方法签名**:
    ```go
    func (a *App) GetOllamaServers() ([]types.OllamaServerConfig, error)
    ```
*   **实现细节**: 直接调用 `configMgr.GetServers()`。

### 3.2 核心依赖系统

#### 3.2.1 外部依赖
*   **configMgr.GetServerByID(serverID string)**: 根据ID获取单个服务器配置 (来自 ollama_config.go)
*   **Go 标准库 net/http**: 用于创建、发送和处理 HTTP 请求/响应
*   **Go 标准库 net/url**: 用于拼接和解析 URL 及查询参数
*   **Go 标准库 io**: 用于读取响应体
*   **Go 标准库 strings**: 用于创建请求体 io.Reader

#### 3.2.2 内部工具函数
```go
// URL构建工具
func BuildURLWithQuery(baseURL, path string, queryParams map[string]string) (string, error)

// HTTP客户端创建
func CreateHTTPClientWithTimeout(timeout time.Duration) *http.Client

// 响应体读取
func ReadResponseBody(resp *http.Response) (string, error)

// 请求体处理
func ProcessRequestBody(body types.RequestBody) (io.Reader, string, error)
```

### 3.3 数据传输对象

#### 3.3.1 请求对象
```go
// API请求结构
type ApiRequest struct {
    Method           string          `json:"method" validate:"required,oneof=GET POST PUT DELETE HEAD PATCH OPTIONS"`
    SelectedServerID string          `json:"selectedServerId" validate:"required"`
    Path             string          `json:"path" validate:"required"`
    QueryParams      []QueryParam    `json:"queryParams"`
    Headers          []RequestHeader `json:"headers"`
    Body             RequestBody     `json:"body"`
}

// 查询参数
type QueryParam struct {
    Key     string `json:"key"`
    Value   string `json:"value"`
    Enabled bool   `json:"enabled"`
}

// 请求头
type RequestHeader struct {
    Key     string `json:"key"`
    Value   string `json:"value"`
    Enabled bool   `json:"enabled"`
}

// 请求体
type RequestBody struct {
    Type           RequestBodyType      `json:"type"`
    RawContent     string               `json:"rawContent,omitempty"`
    RawContentType RawBodyContentType   `json:"rawContentType,omitempty"`
    FormData       []FormDataItem       `json:"formData,omitempty"`
}
```

#### 3.3.2 响应对象
```go
// API响应结构
type ApiResponse struct {
    StatusCode        int             `json:"statusCode"`
    StatusText        string          `json:"statusText"`
    Headers           []RequestHeader `json:"headers"`
    Body              string          `json:"body"`
    RequestDurationMs int64           `json:"requestDurationMs"`
    Error             string          `json:"error,omitempty"`
}

// 服务器配置
type OllamaServerConfig struct {
    ID       string `json:"id"`
    Name     string `json:"name"`
    BaseURL  string `json:"baseUrl"`
    IsActive bool   `json:"isActive"`
}
```

## 4. Application（应用实现）

### 4.1 前端API调用

#### 4.1.1 TypeScript接口定义
```typescript
// Wails绑定接口
declare global {
  interface Window {
    go: {
      main: {
        App: {
          // HTTP请求发送
          SendHttpRequest(request: ApiRequest): Promise<ApiResponse>;
          
          // 服务器配置获取
          GetOllamaServers(): Promise<OllamaServerConfig[]>;
        };
      };
    };
  }
}
```

#### 4.1.2 API调用封装
```typescript
// API调用服务
class OllamaApiDebuggerService {
  // 发送HTTP请求
  async sendRequest(request: ApiRequest): Promise<ApiResponse> {
    try {
      const response = await window.go.main.App.SendHttpRequest(request);
      return response;
    } catch (error) {
      throw new ApiError('请求发送失败', error);
    }
  }
  
  // 获取服务器列表
  async getServers(): Promise<OllamaServerConfig[]> {
    try {
      return await window.go.main.App.GetOllamaServers();
    } catch (error) {
      throw new ApiError('获取服务器列表失败', error);
    }
  }
}

// 错误处理类
class ApiError extends Error {
  constructor(message: string, public cause?: any) {
    super(message);
    this.name = 'ApiError';
  }
}
```

### 4.2 后端API实现

#### 4.2.1 核心实现逻辑
```go
// SendHttpRequest 的完整实现流程
func (d *OllamaApiDebugger) SendHttpRequest(request types.ApiRequest) (types.ApiResponse, error) {
    var apiResponse types.ApiResponse
    startTime := time.Now()
    
    // 1. 参数验证
    if err := d.validateRequest(request); err != nil {
        apiResponse.Error = err.Error()
        return apiResponse, nil
    }
    
    // 2. 获取服务器配置
    serverConfig, err := d.configMgr.GetServerByID(request.SelectedServerID)
    if err != nil {
        apiResponse.Error = fmt.Sprintf("无法获取服务器配置: %v", err)
        return apiResponse, nil
    }
    
    // 3. 构建HTTP请求
    httpReq, err := d.buildHttpRequest(request, serverConfig)
    if err != nil {
        apiResponse.Error = fmt.Sprintf("构建请求失败: %v", err)
        return apiResponse, nil
    }
    
    // 4. 发送请求
    client := CreateHTTPClientWithTimeout(30 * time.Second)
    resp, err := client.Do(httpReq)
    if err != nil {
        apiResponse.Error = fmt.Sprintf("请求发送失败: %v", err)
        return apiResponse, nil
    }
    defer resp.Body.Close()
    
    // 5. 处理响应
    return d.processResponse(resp, time.Since(startTime))
}
```

#### 4.2.2 辅助方法实现
```go
// 请求验证
func (d *OllamaApiDebugger) validateRequest(request types.ApiRequest) error {
    if request.SelectedServerID == "" {
        return errors.New("请选择Ollama服务器")
    }
    if request.Method == "" {
        return errors.New("HTTP方法不能为空")
    }
    if request.Path == "" {
        return errors.New("API路径不能为空")
    }
    return nil
}

// 构建HTTP请求
func (d *OllamaApiDebugger) buildHttpRequest(request types.ApiRequest, serverConfig types.OllamaServerConfig) (*http.Request, error) {
    // URL构建
    queryParams := make(map[string]string)
    for _, param := range request.QueryParams {
        if param.Enabled {
            queryParams[param.Key] = param.Value
        }
    }
    
    finalURL, err := BuildURLWithQuery(serverConfig.BaseURL, request.Path, queryParams)
    if err != nil {
        return nil, err
    }
    
    // 请求体处理
    bodyReader, contentType, err := ProcessRequestBody(request.Body)
    if err != nil {
        return nil, err
    }
    
    // 创建请求
    req, err := http.NewRequestWithContext(d.ctx, strings.ToUpper(request.Method), finalURL, bodyReader)
    if err != nil {
        return nil, err
    }
    
    // 设置请求头
    if contentType != "" {
        req.Header.Set("Content-Type", contentType)
    }
    
    for _, header := range request.Headers {
        if header.Enabled {
            req.Header.Set(header.Key, header.Value)
        }
    }
    
    return req, nil
}
```

### 4.3 错误处理机制

#### 4.3.1 错误类型定义
```go
// 错误类型常量
const (
    ErrInvalidRequest   = "INVALID_REQUEST"
    ErrServerNotFound   = "SERVER_NOT_FOUND"
    ErrNetworkError     = "NETWORK_ERROR"
    ErrTimeout          = "TIMEOUT_ERROR"
    ErrInvalidResponse  = "INVALID_RESPONSE"
)

// 错误信息映射
var ErrorMessages = map[string]string{
    ErrInvalidRequest:  "请求参数错误",
    ErrServerNotFound:  "服务器不存在",
    ErrNetworkError:    "网络连接错误",
    ErrTimeout:         "请求超时",
    ErrInvalidResponse: "响应数据错误",
}
```

#### 4.3.2 统一错误处理
```go
// 错误处理函数
func (d *OllamaApiDebugger) handleError(err error) string {
    switch {
    case strings.Contains(err.Error(), "timeout"):
        return ErrorMessages[ErrTimeout]
    case strings.Contains(err.Error(), "connection refused"):
        return ErrorMessages[ErrNetworkError]
    case strings.Contains(err.Error(), "no such host"):
        return ErrorMessages[ErrNetworkError]
    default:
        return err.Error()
    }
}
```

## 5. Assurance（质量保证）

### 5.1 API测试策略

#### 单元测试
- **方法测试**: 每个API方法的独立测试
- **参数验证**: 边界值和异常情况测试
- **错误处理**: 各种错误情况的处理测试

#### 集成测试
- **端到端测试**: 完整的请求响应流程测试
- **真实API测试**: 对真实Ollama服务的测试
- **性能测试**: 并发请求和压力测试

### 5.2 API文档生成
- **自动生成**: 基于代码注释生成文档
- **交互式文档**: 支持在线测试的API文档
- **示例代码**: 完整的调用示例

### 5.3 监控和日志
- **调用统计**: API调用次数和耗时统计
- **错误监控**: 错误率和错误类型统计
- **性能监控**: 响应时间和资源使用监控

## 6. Action（行动计划）

### 6.1 API开发计划

#### 阶段1: 核心API (1周)
- ✅ SendHttpRequest 实现
- ✅ GetOllamaServers 实现
- ✅ 基础错误处理
- ✅ 数据结构定义

#### 阶段2: 增强功能 (1周)
- 🔄 **请求取消**: 支持长时间请求的取消
- 🔄 **请求验证**: 更严格的参数验证
- 🔄 **错误处理**: 更细致的错误分类
- 🔄 **日志记录**: 完善的日志系统

#### 阶段3: 质量保证 (1周)
- 📅 **单元测试**: 完整的测试用例
- 📅 **集成测试**: 端到端测试
- 📅 **性能测试**: 并发和压力测试
- 📅 **文档完善**: API文档和示例

### 6.2 扩展计划

#### 近期扩展 (1-2个月)
- 📅 **请求历史API**: 保存和管理请求历史
- 📅 **收藏API**: 收藏常用请求的API
- 📅 **批量操作API**: 批量发送请求
- 📅 **导入导出API**: 配置和数据的导入导出

#### 中期扩展 (3-6个月)
- 📅 **测试套件API**: 测试用例集合管理
- 📅 **性能监控API**: 请求性能数据收集
- 📅 **协作功能API**: 多用户协作支持
- 📅 **插件系统API**: 可扩展的插件接口

### 6.3 API版本管理
- **版本策略**: 语义化版本控制
- **兼容性**: 向后兼容保证
- **废弃策略**: 渐进式废弃机制
- **迁移指南**: 版本升级指导