# Ollama API 调试器模块 - 数据结构

## 1. Architecture（架构设计）

### 1.1 数据架构概述
Ollama API 调试器采用简化的数据架构，主要依赖前端状态管理和后端直接HTTP调用，无需复杂的数据持久化存储。

### 1.2 数据流架构
```
前端状态层 (Vue Reactive)
    ↕
Wails 绑定层 (Go Methods)
    ↕
HTTP 客户端层 (net/http)
    ↕
Ollama API 服务
```

### 1.3 数据存储策略
- **内存状态**: Vue Reactive 管理前端状态
- **会话存储**: 暂无需求，所有数据都是临时性的
- **配置集成**: 依赖 OllamaConfigManager 获取服务器配置
- **缓存机制**: 暂无需求，每次请求都是实时的

## 2. Analysis（需求分析）

### 2.1 数据实体分析
| 实体 | 用途 | 存储方式 | 访问频率 |
|------|------|----------|----------|
| ApiRequest | HTTP请求数据 | 内存状态 | 高 |
| ApiResponse | HTTP响应数据 | 内存状态 | 高 |
| ApiTemplate | API模板数据 | 硬编码 | 中 |
| ServerConfig | 服务器配置 | 外部管理 | 低 |

### 2.2 数据关系分析
```
ApiTemplate (1:1) → ApiRequest
ApiRequest (1:1) → ApiResponse
ServerConfig (1:N) → ApiRequest
```

### 2.3 数据访问模式
- **一次性访问**: 每次请求都是独立的，无需持久化
- **实时性要求**: 请求和响应都需要实时处理
- **简单操作**: 主要是创建和读取操作，无复杂查询

## 3. Architecture（数据架构）

### 3.1 前端数据结构

#### 3.1.1 核心状态接口
前端请求数据结构 (用于 UI 绑定和传递给后端)

```typescript
// types.ts (Conceptual)

interface KeyValue {
  key: string;
  value: string;
}

interface KeyValueEnablable extends KeyValue {
  enabled: boolean;
}

enum RequestBodyType {
  None = 'none',
  Raw = 'raw',
  FormData = 'formData',
}

enum RawBodyContentType {
  Json = 'application/json',
  Text = 'text/plain',
  Html = 'text/html',
  Xml = 'application/xml',
}

interface RequestBody {
  type: RequestBodyType;
  rawContent?: string;
  rawContentType?: RawBodyContentType;
  formData?: KeyValue[];
}

interface ApiRequest {
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'PATCH' | 'OPTIONS';
  selectedServerId: string;
  path: string;
  queryParams: KeyValueEnablable[];
  headers: KeyValueEnablable[];
  body: RequestBody;
}
```

#### 3.1.2 应用状态管理
```typescript
// 主应用状态
interface DebuggerState {
  // 当前请求状态
  currentRequest: ApiRequest;
  
  // 响应状态
  currentResponse: ApiResponse | null;
  
  // UI 状态
  ui: {
    isLoading: boolean;
    error: string | null;
    activeTab: 'params' | 'headers' | 'body';
    activeResponseTab: 'body' | 'headers';
    activeApiName: string;
  };
  
  // 配置状态
  config: {
    servers: OllamaServerConfig[];
    apiTemplates: ApiTemplate[];
  };
}
```

#### 3.1.3 API 模板结构
```typescript
// API 模板定义
interface ApiTemplate {
  key: string;                    // API 标识符
  method: HttpMethod;             // HTTP 方法
  path: string;                   // API 路径
  body: RequestBody;              // 请求体模板
  queryParams: KeyValueEnablable[]; // 查询参数模板
  headers: KeyValueEnablable[];   // 请求头模板
}

// 完整的 API 模板列表
const API_TEMPLATES: ApiTemplate[] = [
  {
    key: 'generateCompletion',
    method: 'POST',
    path: '/api/generate',
    body: {
      type: RequestBodyType.Raw,
      rawContentType: RawBodyContentType.Json,
      rawContent: JSON.stringify({
        model: 'llama3.2',
        keep_alive: 0
      }, null, 2)
    },
    queryParams: [],
    headers: [{
      key: 'Content-Type',
      value: 'application/json',
      enabled: true
    }]
  },
  // ... 其他10个API模板
];
```

### 3.2 后端数据结构

#### 3.2.1 Go 数据模型
后端请求处理 (Go)

为确保对请求参数（特别是请求头）的完全控制，后端实现已**放弃**使用 `duolasdk/core/net.go` 中的 `HttpCli` 封装。

**当前实现**: `ollama_api_debugger.go` 中的 `SendHttpRequest` 函数直接使用 Go 标准库 `net/http` 来完成请求的构建和发送。

*   **URL构建**: 使用 `url.JoinPath` 和 `url.Parse` 拼接 BaseURL, Path 和查询参数。
*   **请求体构建**: 使用 `strings.NewReader` 将前端传来的 `rawContent` 或编码后的 `formData` 转换为 `io.Reader`。
*   **请求头构建**: 手动创建一个 `http.Header` 对象，并逐一设置从前端传来的所有启用的请求头，包括根据请求体类型动态设置的 `Content-Type`。
*   **请求发送**: 使用 `http.NewRequestWithContext` 创建一个 `*http.Request` 对象，并由标准的 `http.Client` 的 `Do` 方法发送。

这种方式绕过了所有中间封装，保证了前端所见即后端所发。

#### 3.2.2 HTTP 请求处理
```go
// HTTP 请求构建器
type HttpRequestBuilder struct {
    baseURL     string
    path        string
    method      string
    queryParams map[string]string
    headers     map[string]string
    body        io.Reader
}

// 构建完整的 HTTP 请求
func (b *HttpRequestBuilder) Build(ctx context.Context) (*http.Request, error) {
    // 1. 构建 URL
    finalURL, err := BuildURLWithQuery(b.baseURL, b.path, b.queryParams)
    if err != nil {
        return nil, err
    }
    
    // 2. 创建请求
    req, err := http.NewRequestWithContext(ctx, b.method, finalURL, b.body)
    if err != nil {
        return nil, err
    }
    
    // 3. 设置请求头
    for key, value := range b.headers {
        req.Header.Set(key, value)
    }
    
    return req, nil
}
```

### 3.3 数据验证

#### 3.3.1 前端验证
```typescript
// 请求数据验证
function validateApiRequest(request: ApiRequest): ValidationResult {
  const errors: string[] = [];
  
  // 验证服务器选择
  if (!request.selectedServerId) {
    errors.push('请选择Ollama服务器');
  }
  
  // 验证API路径
  if (!request.path || !request.path.startsWith('/')) {
    errors.push('API路径必须以/开头');
  }
  
  // 验证JSON格式
  if (request.body.type === RequestBodyType.Raw && 
      request.body.rawContentType === RawBodyContentType.Json) {
    try {
      JSON.parse(request.body.rawContent);
    } catch (e) {
      errors.push('JSON格式错误');
    }
  }
  
  return {
    valid: errors.length === 0,
    errors
  };
}
```

#### 3.3.2 后端验证
```go
// 请求参数验证
func ValidateApiRequest(request types.ApiRequest) error {
    if request.SelectedServerID == "" {
        return errors.New("未选择服务器")
    }
    
    if request.Method == "" {
        return errors.New("HTTP方法不能为空")
    }
    
    if request.Path == "" {
        return errors.New("API路径不能为空")
    }
    
    return nil
}
```

## 4. Application（应用实现）

### 4.1 数据转换层

#### 4.1.1 请求数据转换
```go
// 将前端请求转换为HTTP请求
func ConvertToHttpRequest(apiReq types.ApiRequest, serverConfig types.OllamaServerConfig) (*HttpRequestBuilder, error) {
    builder := &HttpRequestBuilder{
        baseURL: serverConfig.BaseURL,
        path:    apiReq.Path,
        method:  strings.ToUpper(apiReq.Method),
    }
    
    // 转换查询参数
    queryParams := make(map[string]string)
    for _, param := range apiReq.QueryParams {
        if param.Enabled {
            queryParams[param.Key] = param.Value
        }
    }
    builder.queryParams = queryParams
    
    // 转换请求头
    headers := make(map[string]string)
    for _, header := range apiReq.Headers {
        if header.Enabled {
            headers[header.Key] = header.Value
        }
    }
    
    // 转换请求体
    bodyReader, contentType, err := ConvertRequestBody(apiReq.Body)
    if err != nil {
        return nil, err
    }
    
    if contentType != "" {
        headers["Content-Type"] = contentType
    }
    
    builder.headers = headers
    builder.body = bodyReader
    
    return builder, nil
}
```

#### 4.1.2 响应数据转换
```go
// 将HTTP响应转换为前端响应
func ConvertFromHttpResponse(resp *http.Response, duration time.Duration) (types.ApiResponse, error) {
    apiResp := types.ApiResponse{
        StatusCode:        resp.StatusCode,
        StatusText:        http.StatusText(resp.StatusCode),
        RequestDurationMs: duration.Milliseconds(),
    }
    
    // 读取响应体
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return apiResp, err
    }
    apiResp.Body = string(body)
    
    // 转换响应头
    for key, values := range resp.Header {
        apiResp.Headers = append(apiResp.Headers, types.RequestHeader{
            Key:     key,
            Value:   strings.Join(values, ", "),
            Enabled: true,
        })
    }
    
    return apiResp, nil
}
```

### 4.2 工具函数

#### 4.2.1 URL 构建工具
```go
// 构建带查询参数的URL
func BuildURLWithQuery(baseURL, path string, queryParams map[string]string) (string, error) {
    // 解析基础URL
    base, err := url.Parse(baseURL)
    if err != nil {
        return "", err
    }
    
    // 拼接路径
    fullURL, err := url.JoinPath(base.String(), path)
    if err != nil {
        return "", err
    }
    
    // 添加查询参数
    if len(queryParams) > 0 {
        parsedURL, err := url.Parse(fullURL)
        if err != nil {
            return "", err
        }
        
        query := parsedURL.Query()
        for key, value := range queryParams {
            query.Set(key, value)
        }
        parsedURL.RawQuery = query.Encode()
        fullURL = parsedURL.String()
    }
    
    return fullURL, nil
}
```

#### 4.2.2 请求体处理工具
```go
// 处理不同类型的请求体
func ConvertRequestBody(body types.RequestBody) (io.Reader, string, error) {
    switch body.Type {
    case types.RequestBodyTypeNone:
        return nil, "", nil
        
    case types.RequestBodyTypeRaw:
        return strings.NewReader(body.RawContent), string(body.RawContentType), nil
        
    case types.RequestBodyTypeFormData:
        formData := url.Values{}
        for _, field := range body.FormData {
            formData.Set(field.Key, field.Value)
        }
        return strings.NewReader(formData.Encode()), "application/x-www-form-urlencoded", nil
        
    default:
        return nil, "", errors.New("不支持的请求体类型")
    }
}
```

## 5. Assurance（质量保证）

### 5.1 数据完整性
- **类型安全**: TypeScript 和 Go 的强类型系统
- **数据验证**: 前后端双重验证机制
- **错误处理**: 统一的错误处理和传播

### 5.2 数据安全性
- **输入过滤**: 防止恶意输入和注入攻击
- **参数编码**: URL 和请求体参数正确编码
- **错误隐藏**: 不暴露敏感的系统信息

### 5.3 性能保证
- **内存管理**: 及时清理大型响应数据
- **序列化优化**: 高效的JSON序列化和反序列化
- **网络优化**: 合理的超时设置和重试机制

## 6. Action（行动计划）

### 6.1 数据结构实现计划

#### 阶段1: 基础结构 (1周)
- ✅ 核心数据模型定义
- ✅ 前后端类型定义一致性
- ✅ 基础数据验证规则
- ✅ API模板数据结构

#### 阶段2: 高级功能 (1周)
- ✅ 数据转换层实现
- ✅ 错误处理机制
- ✅ 工具函数完善
- ✅ 性能优化

#### 阶段3: 质量保证 (1周)
- ✅ 单元测试编写
- ✅ 集成测试验证
- ✅ 数据安全性检查
- ✅ 性能测试

### 6.2 数据治理

#### 数据质量管理
- **数据验证**: 严格的输入验证和格式检查
- **错误监控**: 数据转换和处理错误监控
- **日志记录**: 关键数据操作的日志记录

#### 数据安全管理
- **敏感数据过滤**: 防止敏感信息泄露
- **输入清洗**: 防止XSS和注入攻击
- **数据加密**: 必要时对敏感数据进行加密

### 6.3 扩展计划

#### 近期扩展 (1-2个月)
- 📅 **请求历史**: 添加请求历史记录数据结构
- 📅 **收藏功能**: 添加收藏请求的数据结构
- 📅 **环境变量**: 支持动态参数替换
- 📅 **批量操作**: 批量请求的数据结构

#### 中期扩展 (3-6个月)
- 📅 **测试套件**: 测试用例集合的数据结构
- 📅 **性能监控**: 性能指标的数据结构
- 📅 **协作功能**: 多用户协作的数据结构
- 📅 **插件系统**: 可扩展的插件数据结构

响应同样由 `net/http` 的 `*http.Response` 对象处理。

*   从 `resp.StatusCode` 和 `resp.Header` 中读取状态码和响应头。
*   使用 `io.ReadAll` 从 `resp.Body` 中读取响应体字符串。
*   将这些信息组装成 `types.ApiResponse` 结构体返回给前端。

## 4. 前后端交互数据结构 (Go & TypeScript)

这些结构定义在 `tools-ollama/types/types.go` 中，并由 Wails 自动生成对应的 TypeScript 版本。

```go
// tools-ollama/types/types.go

// (只展示相关部分)

type FormDataItem struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type RequestBody struct {
	Type           RequestBodyType      `json:"type"`
	RawContent     string               `json:"rawContent,omitempty"`
	RawContentType RawBodyContentType   `json:"rawContentType,omitempty"`
	FormData       []FormDataItem       `json:"formData,omitempty"` // 已修正为正确的 struct slice
}

type ApiRequest struct {
	Method           string          `json:"method"`
	SelectedServerID string          `json:"selectedServerId"`
	Path             string          `json:"path"`
	QueryParams      []QueryParam    `json:"queryParams"`
	Headers          []RequestHeader `json:"headers"`
	Body             RequestBody     `json:"body"`
}

type ApiResponse struct {
	StatusCode        int             `json:"statusCode"`
	StatusText        string          `json:"statusText"`
	Headers           []RequestHeader `json:"headers"`
	Body              string          `json:"body"`
	RequestDurationMs int64           `json:"requestDurationMs"`
	Error             string          `json:"error,omitempty"`
}
```
