# ApiDebugger 组件使用指南

## 概述

`ApiDebugger` 是一个通用的 API 调试组件，类似于 Postman 的功能，可以在任何 Vue 项目中复用。它提供了完整的 HTTP 请求构建和响应查看功能。

## 组件特性

- 🚀 **类 Postman 界面**: 熟悉的用户体验，降低学习成本
- 🔧 **完整的请求构建**: 支持查询参数、请求头、请求体配置
- 📊 **响应展示**: 自动格式化 JSON，显示状态码和耗时
- 🎯 **高度可定制**: 支持自定义请求处理器和基础 URL
- 💡 **TypeScript 支持**: 完整的类型定义

## 基本用法

### 1. 导入组件

```vue
<script setup lang="ts">
import ApiDebugger from '@/components/ApiDebugger.vue';
</script>
```

### 2. 简单使用

```vue
<template>
  <div class="container">
    <ApiDebugger 
      url-placeholder="输入 API 地址"
    />
  </div>
</template>
```

### 3. 带基础 URL

```vue
<template>
  <div class="container">
    <ApiDebugger 
      base-url="https://api.example.com"
      url-placeholder="/api/users"
    />
  </div>
</template>
```

## 高级用法

### 1. 自定义请求处理器

```vue
<template>
  <div class="container">
    <ApiDebugger 
      :base-url="baseUrl"
      :on-request="handleCustomRequest"
    />
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import ApiDebugger from '@/components/ApiDebugger.vue';

const baseUrl = ref('https://api.example.com');

// 自定义请求处理器
const handleCustomRequest = async (request) => {
  // 添加认证头
  const headers = {
    'Authorization': 'Bearer your-token',
    ...request.headers.reduce((acc, h) => {
      if (h.enabled && h.key) {
        acc[h.key] = h.value;
      }
      return acc;
    }, {})
  };

  // 构建完整 URL
  let url = request.url;
  if (baseUrl.value && !url.startsWith('http')) {
    url = baseUrl.value.replace(/\/$/, '') + '/' + url.replace(/^\//, '');
  }

  // 添加查询参数
  const enabledParams = request.queryParams.filter(p => p.enabled && p.key);
  if (enabledParams.length > 0) {
    const params = new URLSearchParams();
    enabledParams.forEach(p => params.append(p.key, p.value));
    url += (url.includes('?') ? '&' : '?') + params.toString();
  }

  // 构建请求体
  let body;
  if (request.body.type === 'raw' && request.body.rawContent) {
    body = request.body.rawContent;
    if (request.body.rawContentType && !headers['Content-Type']) {
      headers['Content-Type'] = request.body.rawContentType;
    }
  } else if (request.body.type === 'formData') {
    const formData = new FormData();
    request.body.formData.filter(f => f.key).forEach(f => {
      formData.append(f.key, f.value);
    });
    body = formData;
  }

  // 发送请求
  const startTime = Date.now();
  try {
    const response = await fetch(url, {
      method: request.method,
      headers,
      body: ['GET', 'HEAD'].includes(request.method) ? undefined : body
    });
    const endTime = Date.now();

    const responseHeaders = Array.from(response.headers.entries()).map(([key, value]) => ({
      key,
      value
    }));

    return {
      statusCode: response.status,
      statusText: response.statusText,
      headers: responseHeaders,
      body: await response.text(),
      requestDurationMs: endTime - startTime
    };
  } catch (error) {
    throw new Error(`请求失败: ${error.message}`);
  }
};
</script>
```

### 2. 使用组件引用

```vue
<template>
  <div class="container">
    <div class="toolbar">
      <button @click="loadApiTemplate">加载模板</button>
      <button @click="clearAll">清空</button>
    </div>
    
    <ApiDebugger 
      ref="apiDebuggerRef"
      :base-url="baseUrl"
    />
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import ApiDebugger from '@/components/ApiDebugger.vue';

const apiDebuggerRef = ref();
const baseUrl = ref('https://jsonplaceholder.typicode.com');

// 加载 API 模板
const loadApiTemplate = () => {
  if (apiDebuggerRef.value) {
    apiDebuggerRef.value.setRequest({
      method: 'POST',
      url: '/posts',
      headers: [
        { key: 'Content-Type', value: 'application/json', enabled: true }
      ],
      body: {
        type: 'raw',
        rawContentType: 'application/json',
        rawContent: JSON.stringify({
          title: 'foo',
          body: 'bar',
          userId: 1
        }, null, 2)
      }
    });
  }
};

// 清空所有内容
const clearAll = () => {
  if (apiDebuggerRef.value) {
    apiDebuggerRef.value.setRequest({
      method: 'GET',
      url: '',
      queryParams: [],
      headers: [],
      body: {
        type: 'none',
        rawContent: '',
        rawContentType: 'application/json',
        formData: []
      }
    });
    apiDebuggerRef.value.clearResponse();
  }
};
</script>
```

## Props 属性

| 属性 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `baseUrl` | `string` | `''` | 基础 URL，会自动拼接到请求 URL 前 |
| `urlPlaceholder` | `string` | `'输入请求 URL'` | URL 输入框的占位符 |
| `onRequest` | `function` | `undefined` | 自定义请求处理器函数 |

## 暴露的方法

### setRequest(request)

设置请求参数。

```typescript
interface ApiRequest {
  method: string;
  url: string;
  queryParams: KeyValue[];
  headers: KeyValue[];
  body: RequestBody;
}

interface KeyValue {
  key: string;
  value: string;
  enabled: boolean;
}

interface RequestBody {
  type: 'none' | 'raw' | 'formData';
  rawContent: string;
  rawContentType: string;
  formData: FormDataItem[];
}
```

### sendRequest()

手动触发请求发送。

### clearResponse()

清空响应结果。

## 样式定制

组件使用了 scoped 样式，如果需要自定义样式，可以使用深度选择器：

```vue
<style>
.container :deep(.api-debugger) {
  border-radius: 12px;
}

.container :deep(.send-btn) {
  background-color: #10b981;
}
</style>
```

## 完整示例

以下是一个完整的使用示例，展示了如何在实际项目中使用 ApiDebugger 组件：

```vue
<template>
  <div class="api-test-page">
    <div class="header">
      <h1>API 测试工具</h1>
      <div class="server-selector">
        <label>服务器:</label>
        <select v-model="selectedServer">
          <option value="">选择服务器</option>
          <option v-for="server in servers" :key="server.id" :value="server.url">
            {{ server.name }}
          </option>
        </select>
      </div>
    </div>

    <div class="content">
      <div class="sidebar">
        <h3>API 模板</h3>
        <ul class="api-templates">
          <li 
            v-for="template in apiTemplates" 
            :key="template.name"
            @click="loadTemplate(template)"
            class="template-item"
          >
            <span :class="['method', template.method.toLowerCase()]">
              {{ template.method }}
            </span>
            {{ template.name }}
          </li>
        </ul>
      </div>

      <div class="main">
        <ApiDebugger 
          ref="debuggerRef"
          :base-url="selectedServer"
          :on-request="handleRequest"
        />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive } from 'vue';
import ApiDebugger from '@/components/ApiDebugger.vue';

const debuggerRef = ref();
const selectedServer = ref('');

const servers = reactive([
  { id: 1, name: '开发环境', url: 'https://dev-api.example.com' },
  { id: 2, name: '测试环境', url: 'https://test-api.example.com' },
  { id: 3, name: '生产环境', url: 'https://api.example.com' }
]);

const apiTemplates = reactive([
  {
    name: '获取用户列表',
    method: 'GET',
    url: '/api/users',
    queryParams: [
      { key: 'page', value: '1', enabled: true },
      { key: 'limit', value: '10', enabled: true }
    ]
  },
  {
    name: '创建用户',
    method: 'POST',
    url: '/api/users',
    headers: [
      { key: 'Content-Type', value: 'application/json', enabled: true }
    ],
    body: {
      type: 'raw',
      rawContentType: 'application/json',
      rawContent: JSON.stringify({
        name: 'John Doe',
        email: 'john@example.com'
      }, null, 2)
    }
  }
]);

const loadTemplate = (template) => {
  if (debuggerRef.value) {
    debuggerRef.value.setRequest({
      method: template.method,
      url: template.url,
      queryParams: template.queryParams || [],
      headers: template.headers || [],
      body: template.body || {
        type: 'none',
        rawContent: '',
        rawContentType: 'application/json',
        formData: []
      }
    });
  }
};

const handleRequest = async (request) => {
  // 添加认证头
  const authToken = localStorage.getItem('auth_token');
  if (authToken) {
    request.headers.push({
      key: 'Authorization',
      value: `Bearer ${authToken}`,
      enabled: true
    });
  }

  // 使用默认的 fetch 处理
  // 这里可以添加更多自定义逻辑
  return null; // 返回 null 使用默认处理
};
</script>

<style scoped>
.api-test-page {
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.header {
  padding: 1rem;
  background: #fff;
  border-bottom: 1px solid #e2e8f0;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.server-selector select {
  padding: 0.5rem;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  margin-left: 0.5rem;
}

.content {
  flex: 1;
  display: flex;
  overflow: hidden;
}

.sidebar {
  width: 250px;
  background: #fff;
  border-right: 1px solid #e2e8f0;
  padding: 1rem;
  overflow-y: auto;
}

.api-templates {
  list-style: none;
  padding: 0;
  margin: 0;
}

.template-item {
  padding: 0.75rem;
  cursor: pointer;
  border-radius: 6px;
  margin-bottom: 0.5rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  transition: background-color 0.2s;
}

.template-item:hover {
  background-color: #f1f5f9;
}

.method {
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.75rem;
  font-weight: bold;
  color: white;
  min-width: 50px;
  text-align: center;
}

.method.get { background-color: #3b82f6; }
.method.post { background-color: #10b981; }
.method.put { background-color: #f59e0b; }
.method.delete { background-color: #ef4444; }

.main {
  flex: 1;
  padding: 1rem;
  overflow: hidden;
}
</style>
```

## 总结

`ApiDebugger` 组件提供了一个完整的 API 调试解决方案，具有以下优势：

1. **易于使用**: 简单的 props 配置即可开始使用
2. **高度可定制**: 支持自定义请求处理器和样式
3. **功能完整**: 涵盖了 API 调试的所有常用功能
4. **类型安全**: 完整的 TypeScript 支持
5. **响应式设计**: 适配不同屏幕尺寸

通过这个组件，你可以快速在任何 Vue 项目中集成 API 调试功能，提高开发效率。