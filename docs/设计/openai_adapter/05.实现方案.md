# 5. 实现方案

本方案描述了如何实现一个由前端页面动态控制、可配置、带实时日志和 API 文档的 OpenAI 适配器服务。

## 5.1. 总体架构

架构核心不变，依然围绕 `OpenAIAdapterManager` 作为总控制器。前端通过 Wails API 与其交互，后端通过 Wails Events 将日志实时推送给前端。

## 5.2. 后端实现

### 5.2.1. `OpenAIAdapterManager` 的增强

1.  **修改默认配置**: 在 `NewOpenAIAdapterManager` 中，当加载配置失败时，使用的默认端口应修改为 `11223`。

2.  **实现实时日志系统**:
    -   在 `OpenAIAdapterManager` 中增加一个 `runtimeCtx context.Context` 字段，用于调用 Wails 的 `runtime` 方法。
    -   创建一个新的 `WailsLogWriter` 结构体，它实现 `io.Writer` 接口。
    -   `WailsLogWriter` 的 `Write(p []byte)` 方法会将接收到的字节流（即日志消息）包装成一个 `LogEntry` 对象，并使用 `runtime.EventsEmit(m.runtimeCtx, "openai-adapter-log", logEntry)` 将其发送到前端。
    -   在 `Start()` 方法中，为 `Adapter-Handler` 和 `Adapter-OllamaClient` 创建的 `AppLog` 实例，需要配置为使用我们自定义的 `WailsLogWriter` 作为其输出。

    ```go
    // WailsLogWriter 示例
    type WailsLogWriter struct {
        ctx   context.Context
        level string
    }

    func (w *WailsLogWriter) Write(p []byte) (n int, err error) {
        entry := types.LogEntry{
            Timestamp: time.Now(),
            Level:     w.level,
            Message:   string(p),
        }
        runtime.EventsEmit(w.ctx, "openai-adapter-log", entry)
        return len(p), nil
    }
    ```

### 5.2.2. `app.go` 的改造

1.  **注入 `runtimeCtx`**: 在 `App` 的 `startup` 方法中，将 `ctx` 赋值给 `adapterManager.runtimeCtx`。
2.  **实现 `GetAdapterAPIDocs`**: 

    ```go
    // In app.go
    func (a *App) GetAdapterAPIDocs() (map[string]string, error) {
        cfg := a.adapterManager.GetConfig()
        ip := cfg.ListenIP
        port := cfg.ListenPort

        nonStreamingCurl := fmt.Sprintf(
            `curl http://%s:%d/v1/chat/completions -X POST ...`,
            ip, port,
        )
        streamingCurl := fmt.Sprintf(
            `curl http://%s:%d/v1/chat/completions -X POST ...`,
            ip, port,
        )

        return map[string]string{
            "非流式请求": nonStreamingCurl,
            "流式请求":   streamingCurl,
        }, nil
    }
    ```

## 5.3. 前端实现

### 5.3.1. 重构 `OpenAIAdapterSettings.vue`

- 页面将完全重写，以匹配 `02.界面设计.md` 中描述的、类似 Ollama 的新 UI 风格。
- 使用单个切换按钮，并绑定 `click` 事件到一个有防抖处理的 `toggleService` 方法。
- 页面上的所有配置项（输入框、下拉框）在服务运行时都应设为 `disabled`。

### 5.3.2. 增强 Pinia Store (`openaiAdapter.ts`)

- **增加日志状态**: 在 state 中添加 `logs: LogEntry[]` 和 `isLogDrawerVisible: boolean`。
- **实现环形缓冲区**: 创建一个 action `addLog(log: LogEntry)`。此 action 在添加新日志时，会检查 `logs` 数组的长度。如果超过最大限制（如 500），则从数组头部移除最旧的日志，以实现环形缓冲区，防止内存泄漏。
- **增加 API 文档状态**: 在 state 中添加 `apiDocs: Record<string, string>` 和 `isApiDrawerVisible: boolean`。

### 5.3.3. 页面逻辑

1.  **onMounted**: 
    - 调用 Wails 方法初始化配置、状态和 Ollama 服务列表。
    - **监听日志事件**: 调用 `runtime.EventsOn("openai-adapter-log", ...)`，回调函数会调用 Pinia store 中的 `addLog` action。

2.  **日志抽屉**: 
    - 使用一个 `ref` 来引用日志显示区域的 DOM 元素。
    - 监听 `logs` 数组的变化，当有新日志加入时，自动将滚动条滚动到底部。
    - **清空日志**: 调用 Pinia action，将 `logs` 数组清空。
    - **下载日志**: 将 `logs` 数组中的内容格式化为字符串，创建一个 Blob 对象，并利用 `<a>` 标签的 `download` 属性触发浏览器下载。

3.  **API 文档抽屉**:
    - 当用户点击“查看 API”按钮时，如果 `apiDocs` 为空，则调用后端的 `GetAdapterAPIDocs` 方法获取数据，然后显示抽屉。
    - 将获取到的 `curl` 示例字符串显示在格式化的代码块中。
